diff -urPp backup_migrate.orig/backup_migrate.module backup_migrate/backup_migrate.module
--- backup_migrate.orig/backup_migrate.module	2014-05-15 16:45:10.000000000 +0200
+++ backup_migrate/backup_migrate.module	2014-11-04 11:26:00.000000000 +0100
@@ -1316,7 +1316,7 @@ function backup_migrate_ui_manual_restor
  */
 function backup_migrate_ui_manual_restore_form_submit($form, &$form_state) {
   backup_migrate_include('destinations');
-  $validators = array('file_validate_extensions' => array('gz zip sql mysql bz bz2'));
+  $validators = array('file_validate_extensions' => array('gz zip sql mysql bz bz2 pgsql'));
 
   $values = $form_state['values'];
   if ($values['from'] == 'upload' && $file = file_save_upload('backup_migrate_restore_upload', $validators)) {
diff -urPp backup_migrate.orig/includes/sources.db.pgsql.inc backup_migrate/includes/sources.db.pgsql.inc
--- backup_migrate.orig/includes/sources.db.pgsql.inc	1970-01-01 01:00:00.000000000 +0100
+++ backup_migrate/includes/sources.db.pgsql.inc	2014-11-04 12:02:23.000000000 +0100
@@ -0,0 +1,356 @@
+<?php
+
+backup_migrate_include('sources.db');
+
+/**
+ * @file
+ * Functions to handle the direct to database source.
+ */
+
+/**
+ * A source type for backing up from database server.
+ *
+ * @ingroup backup_migrate_destinations
+ */
+
+class backup_migrate_source_db_pgsql extends backup_migrate_source_db {
+  function type_name() {
+    return t("MySQL Database");
+  }
+
+  /**
+   * Return a list of backup filetypes.
+   */
+  function file_types() {
+    return array(
+      "sql" => array(
+        "extension" => "sql",
+        "filemime" => "text/x-sql",
+        "backup" => TRUE,
+        "restore" => TRUE,
+      ),
+      "pgsql" => array(
+        "extension" => "pgsql",
+        "filemime" => "text/x-sql",
+        "backup" => TRUE,
+        "restore" => TRUE,
+      ),
+    );
+  }
+
+  /**
+   * Return the scheme for this db type.
+   */
+  function default_scheme() {
+    return 'pgsql';
+  }
+
+
+ /**
+   * Declare any mysql databases defined in the settings.php file as a possible source.
+   */
+  function sources() {
+    $out = array();
+    global $databases;
+    foreach ((array)$databases as $db_key => $target) {
+      foreach ((array)$target as $tgt_key => $info) {
+        // Only mysql/mysqli supported by this source.
+        $key = $db_key . ':' . $tgt_key;
+        if ($info['driver'] === 'pgsql') {
+          $url = $info['driver'] . '://' . $info['username'] . ':' . $info['password'] . '@' . $info['host'] . (isset($info['port']) ? ':' . $info['port'] : '') . '/' . $info['database'];
+          if ($source = backup_migrate_create_destination('pgsql', array('url' => $url))) {
+            // Treat the default database differently because it is probably the only one available.
+            if ($key == 'default:default') {
+              $source->set_id('db');
+              $source->set_name(t('Default Database'));
+              // Dissalow backing up to the default database because that's confusing and potentially dangerous.
+              $source->remove_op('scheduled backup');
+              $source->remove_op('manual backup');
+            }
+            else {
+              $source->set_id('db:'. $key);
+              $source->set_name($key .": ". $source->get_display_location());
+            }
+            $out[$source->get_id()] = $source;
+          }
+        }
+      }
+    }
+    return $out;
+  }
+
+  /**
+   * Get the file type for to backup this source to.
+   */
+  function get_file_type_id() {
+    return 'pgsql';
+  }
+
+  /**
+   * Backup the databases to a file.
+   *
+   *  Returns a list of sql commands, one command per line.
+   *  That makes it easier to import without loading the whole file into memory.
+   *  The files are a little harder to read, but human-readability is not a priority
+   */
+  function _backup_db_to_file($file, $settings) {
+    $lines = 0;
+    $exclude = !empty($settings->filters['exclude_tables']) ? $settings->filters['exclude_tables'] : array();
+    $nodata = !empty($settings->filters['nodata_tables']) ? $settings->filters['nodata_tables'] : array();
+    if ($file->open(TRUE)) {
+			$exclude_array = array_merge($exclude, $nodata);
+			if (!empty($exclude_array)) {
+				$exclude_tables = ' --exclude-table='. join(' --exclude-table=', $exclude_array);
+			} else {
+				$exclude_tables = '';
+			}
+
+	  $dump_cmd = escapeshellcmd("PGPASSWORD=" . $settings->source->dest_url['pass']  . " pg_dump --clean --no-owner --host=" . $settings->source->dest_url['host'] . " --username=" . $settings->source->dest_url['user'] . $exclude_tables . " " . $settings->source->dest_url['path']);
+	   $handle = popen($dump_cmd, "r");
+	   $output = "";
+	   $lines = 0;
+	   while ($output_line = fgets($handle)) {
+	     $output .= $output_line;
+	     $lines++;
+	   }
+	   pclose($handle);
+	   if (!empty($nodata)) {
+	     $structure_tables = ' --table='. join(' --table=', $nodata);
+	     $dump_cmd = escapeshellcmd("PGPASSWORD=" . $settings->source->dest_url['pass']  . " pg_dump --clean --no-owner --schema-only --host=" . $settings->source->dest_url['host'] . " --username=" . $settings->source->dest_url['user'] . $structure_tables . " " . $settings->source->dest_url['path']);
+	     $handle = popen($dump_cmd, "r");
+	     while ($output_line = fgets($handle)) {
+	       $output .= $output_line;
+	       $lines++;
+	     }
+	     pclose($handle);
+	   }
+	   $file->write($output);
+	   $file->close();
+	   return $lines;
+	 } else {
+	   return FALSE;
+	 }
+	}
+
+  /**
+   * Backup the databases to a file.
+   */
+	function _restore_db_from_file($file, $settings) {
+	  $dump_cmd = escapeshellcmd("PGPASSWORD=" . $settings->source->dest_url['pass']  . " psql --host=" . $settings->source->dest_url['host'] . " --username=" . $settings->source->dest_url['user'] . " --file ". $file->filepath() . " " . $settings->source->dest_url['path']);
+		
+	  exec($dump_cmd, $output_array, $return);
+		
+	  $num = count($output_array);
+		
+	  if ($return) {  // 0 == success, non-zero = fail
+	    drupal_set_message(t("Unable to open file %file to restore database", array("%file" => $file->filepath())), 'error');
+	    $num = FALSE;
+	  }
+		
+	  return $num;
+	}
+
+  /**
+   * Get a list of tables in the database.
+   */
+  function _get_table_names() {
+    $out = array();
+    foreach ($this->_get_tables() as $table) {
+      $out[$table['name']] = $table['name'];
+    }
+    return $out;
+  }
+
+  /**
+   * Get a list of views in the database.
+   */
+  function _get_view_names() {
+    $out = array();
+    foreach ($this->_get_views() as $view) {
+      $out[$view['name']] = $view['name'];
+    }
+    return $out;
+  }
+
+  /**
+   * Lock the list of given tables in the database.
+   */
+  function _lock_tables($tables) {
+    if ($tables) {
+      $tables_escaped = array();
+      foreach ($tables as $table) {
+        $tables_escaped[] = '`'. db_escape_table($table) .'`  WRITE';
+      }
+      $this->query('LOCK TABLES '. implode(', ', $tables_escaped));
+    }
+  }
+
+  /**
+   * Unlock all tables in the database.
+   */
+  function _unlock_tables($settings) {
+    $this->query('UNLOCK TABLES');
+  }
+
+  /**
+   * Get a list of tables in the db.
+   */
+  function _get_tables() {
+    $out = array();
+    // get auto_increment values and names of all tables
+    $tables = $this->query("SELECT * FROM information_schema.tables WHERE table_schema = 'public' ORDER by table_name ASC", array(), array('fetch' => PDO::FETCH_ASSOC));
+    foreach ($tables as $table) {
+      // Lowercase the keys because between Drupal 7.12 and 7.13/14 the default query behavior was changed.
+      // See: http://drupal.org/node/1171866
+      $table = array_change_key_case($table);
+      if (!empty($table['engine'])) {
+        $out[$table['name']] = $table;
+      }
+    }
+    return $out;
+  }
+
+  /**
+   * Get a list of views in the db.
+   */
+  function _get_views() {
+    $out = array();
+    // get auto_increment values and names of all tables
+    $tables = $this->query("SELECT * FROM information_schema.views WHERE table_schema = 'public' ORDER by table_name ASC", array(), array('fetch' => PDO::FETCH_ASSOC));
+    foreach ($tables as $table) {
+      // Lowercase the keys because between Drupal 7.12 and 7.13/14 the default query behavior was changed.
+      // See: http://drupal.org/node/1171866
+      $table = array_change_key_case($table);
+      if (empty($table['engine'])) {
+        $out[$table['name']] = $table;
+      }
+    }
+    return $out;
+  }
+
+   /**
+   * Get the sql for the structure of the given view.
+   */
+  function _get_view_create_sql($view) {
+    $out = "";
+    // Switch SQL mode to get rid of "CREATE ALGORITHM..." what requires more permissions + troubles with the DEFINER user
+    $sql_mode = $this->query("SELECT @@SESSION.sql_mode")->fetchField();
+    $this->query("SET sql_mode = 'ANSI'");
+    $result = $this->query("SHOW CREATE VIEW `" . $view['name'] . "`", array(), array('fetch' => PDO::FETCH_ASSOC));
+    $this->query("SET SQL_mode = :mode", array(':mode' => $sql_mode));
+    foreach ($result as $create) {
+      // Lowercase the keys because between Drupal 7.12 and 7.13/14 the default query behavior was changed.
+      // See: http://drupal.org/node/1171866
+      $create = array_change_key_case($create);
+      $out .= "DROP VIEW IF EXISTS `". $view['name'] ."`;\n";
+      $out .= "SET sql_mode = 'ANSI';\n";
+      $out .= strtr($create['create view'], "\n", " ") . ";\n";
+      $out .= "SET sql_mode = '$sql_mode';\n";
+    }
+    return $out;
+  }
+
+
+
+  /**
+   * Get the sql for the structure of the given table.
+   */
+  function _get_table_structure_sql($table) {
+    $out = "";
+    $result = $this->query("SHOW CREATE TABLE `". $table['name'] ."`", array(), array('fetch' => PDO::FETCH_ASSOC));
+    foreach ($result as $create) {
+      // Lowercase the keys because between Drupal 7.12 and 7.13/14 the default query behavior was changed.
+      // See: http://drupal.org/node/1171866
+      $create = array_change_key_case($create);
+      $out .= "DROP TABLE IF EXISTS `". $table['name'] ."`;\n";
+      // Remove newlines and convert " to ` because PDO seems to convert those for some reason.
+      $out .= strtr($create['create table'], array("\n" => ' ', '"' => '`'));
+      if ($table['auto_increment']) {
+        $out .= " AUTO_INCREMENT=". $table['auto_increment'];
+      }
+      $out .= ";\n";
+    }
+    return $out;
+  }
+  
+  /**
+   *  Get the sql to insert the data for a given table
+   */
+  function _dump_table_data_sql_to_file($file, $table) {
+    $rows_per_line = variable_get('backup_migrate_data_rows_per_line', 30);
+    $bytes_per_line = variable_get('backup_migrate_data_bytes_per_line', 2000);
+  
+    $lines = 0;
+    $data = $this->query("SELECT * FROM `". $table['name'] ."`", array(), array('fetch' => PDO::FETCH_ASSOC));
+    $rows = $bytes = 0;
+
+    // Escape backslashes, PHP code, special chars
+    $search = array('\\', "'", "\x00", "\x0a", "\x0d", "\x1a");
+    $replace = array('\\\\', "''", '\0', '\n', '\r', '\Z');
+  
+    $line = array();
+    foreach ($data as $row) {
+      // DB Escape the values.
+      $items = array();
+      foreach ($row as $key => $value) {
+        $items[] = is_null($value) ? "null" : "'". str_replace($search, $replace, $value) ."'";
+      }
+  
+      // If there is a row to be added.
+      if ($items) {
+        // Start a new line if we need to.
+        if ($rows == 0) {
+          $file->write("INSERT INTO `". $table['name'] ."` VALUES ");
+          $bytes = $rows = 0;
+        }
+        // Otherwise add a comma to end the previous entry.
+        else {
+          $file->write(",");
+        }
+  
+        // Write the data itself.
+        $sql = implode(',', $items);
+        $file->write('('. $sql .')');
+        $bytes += strlen($sql);
+        $rows++;
+  
+        // Finish the last line if we've added enough items
+        if ($rows >= $rows_per_line || $bytes >= $bytes_per_line) {
+          $file->write(";\n");
+          $lines++;
+          $bytes = $rows = 0;
+        }
+      }
+    }
+    // Finish any unfinished insert statements.
+    if ($rows > 0) {
+      $file->write(";\n");
+      $lines++;
+    }
+  
+    return $lines;
+  }
+
+  /**
+   * Run a db query on this destination's db.
+   */
+  function query($query, $args = array(), $options = array()) {
+    if ($conn = $this->_get_db_connection()) {
+      return $conn->query($query, $args, $options);
+    }
+  }
+
+
+  /**
+   * Get the version info for the given DB.
+   */
+  function _db_info() {
+    $db = $this->_get_db_connection();
+    return array(
+      'type' => 'pgsql',
+      'version' => $db ? $db->version() : t('Unknown'),
+    );
+  }
+
+}
+
diff -urPp backup_migrate.orig/includes/sources.inc backup_migrate/includes/sources.inc
--- backup_migrate.orig/includes/sources.inc	2014-05-15 16:45:10.000000000 +0200
+++ backup_migrate/includes/sources.inc	2014-11-04 11:44:37.000000000 +0100
@@ -38,6 +38,18 @@ function backup_migrate_create_source($s
   return backup_migrate_crud_create_item('source', $params);
 }
 
+/** 
+* Helper funciton to determine the type of the database we're dealing with
+*/
+function backup_migrate_get_db_type() {
+	global $databases;
+	foreach ((array)$databases as $db_key => $target) {
+  	foreach ((array)$target as $tgt_key => $info) {
+    	return $info['driver'];
+		}
+	}
+}
+
 /**
  * Implementation of hook_backup_migrate_source_subtypes().
  *
@@ -53,6 +65,13 @@ function backup_migrate_backup_migrate_s
       'class' => 'backup_migrate_source_db',
       'can_create' => FALSE,
     ),
+    'pgsql' => array(
+      'type_name' => t('PostgreSQL Database'),
+      'description' => t('Import the backup directly into another PostgreSQL database. Database sources can also be used as a source to backup from.'),
+      'file' => drupal_get_path('module', 'backup_migrate') .'/includes/sources.db.pgsql.inc',
+      'class' => 'backup_migrate_source_db_pgsql',
+      'can_create' => TRUE,
+    ),
     'mysql' => array(
       'type_name' => t('MySQL Database'),
       'description' => t('Import the backup directly into another MySQL database. Database sources can also be used as a source to backup from.'),
